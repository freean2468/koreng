<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.9.4/cytoscape.min.js"></script>

<style>
    body { 
        font: 14px helvetica neue, helvetica, arial, sans-serif;
        margin: 0
    }

    #cy {
        height: 100%;
        width: 100%;
        display: block;
        position: relative;
    }
</style>

<div id="body">

<div id="cols">
<div class="wrapper">
<div class="entry_area">
<article class="hentry">
<hgroup>
    <h1 class="entry-title">~다 표현길</h1>
    <div class="props">
        <time datetime="" pubdate="">2020-01-05 21:26</time>
    </div>
</hgroup>

<div id="content" class="entry-content">
    <p>&nbsp;</p>

    <p style="text-align: center;">&nbsp;</p>
    
    <p style="text-align:center">
        <img alt="" height="150" src="https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/course/1/5641.png" width="150" class="thumbnail">
    </p>
    
    <p style="text-align: center;">상황별 대표적인 관념을 통해 관련된 표현을 정리</p>
    
    <p style="text-align: center;">&nbsp;</p>

    <div id="cy"></div>
    
    <script text="javascript">
        var cy = cytoscape({
        container: document.getElementById('cy'),
    
        boxSelectionEnabled: false,
        autounselectify: true,
    
        style: cytoscape.stylesheet()
            .selector('node')
                .css({
                    'content': 'data(name)',
                    'text-valign': 'center',
                    'color': 'white',
                    'text-outline-width': 2,
                    'text-outline-color': '#000',
                    'background-color': '#000'
                })
            .selector(':selected')
                .css({
                    'background-color': 'black',
                    'line-color': 'black',
                    'target-arrow-color': 'black',
                    'source-arrow-color': 'black',
                    'text-outline-color': 'black'
                }),
    
            elements: {
                    nodes: [
    { data: { id: 'main', name: '중심관념표현' } },
    { data: { id: 'side1', name: '연관표현1'} },
    { data: { id: 'side2', name: '연관표현2'} }
],
edges: [
    { data: { source: 'main', target: 'side2' } },
    { data: { source: 'main', target: 'side1' } }
]},

layout: {
    name: 'cose',

    // Called on 'layoutready'
    ready: function(){},

    // Called on 'layoutstop'
    stop: function(){},

    // Whether to animate while running the layout
    // true : Animate continuously as the layout is running
    // false : Just show the end result
    // 'end' : Animate with the end result, from the initial positions to the end positions
    animate: true,

    // Easing of the animation for animate:'end'
    animationEasing: undefined,

    // The duration of the animation for animate:'end'
    animationDuration: undefined,

    // A function that determines whether the node should be animated
    // All nodes animated by default on animate enabled
    // Non-animated nodes are positioned immediately when the layout starts
    animateFilter: function ( node, i ){ return true; },


    // The layout animates only after this many milliseconds for animate:true
    // (prevents flashing on fast runs)
    animationThreshold: 250,

    // Number of iterations between consecutive screen positions update
    refresh: 20,

    // Whether to fit the network view after when done
    fit: true,

    // Padding on fit
    padding: 30,

    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox: undefined,

    // Excludes the label when calculating node bounding boxes for the layout algorithm
    nodeDimensionsIncludeLabels: false,

    // Randomize the initial positions of the nodes (true) or use existing positions (false)
    randomize: false,

    // Extra spacing between components in non-compound graphs
    componentSpacing: 40,

    // Node repulsion (non overlapping) multiplier
    nodeRepulsion: function( node ){ return 2048; },

    // Node repulsion (overlapping) multiplier
    nodeOverlap: 4,

    // Ideal edge (non nested) length
    idealEdgeLength: function( edge ){ return 32; },

    // Divisor to compute edge forces
    edgeElasticity: function( edge ){ return 32; },

    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor: 1.2,

    // Gravity force (constant)
    gravity: 1,

    // Maximum number of iterations to perform
    numIter: 1000,

    // Initial temperature (maximum node displacement)
    initialTemp: 1000,

    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor: 0.99,

    // Lower temperature threshold (below this point the layout will end)
    minTemp: 1.0

    // name: 'concentric',
    // fit: true, // whether to fit the viewport to the graph
    // padding: 30, // the padding on fit
    // startAngle: 3 / 2 * Math.PI, // where nodes start in radians
    // sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
    // clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
    // equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
    // minNodeSpacing: 50, // min spacing between outside of nodes (used for radius adjustment)
    // boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    // avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    // nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
    // height: undefined, // height of layout area (overrides container height)
    // width: undefined, // width of layout area (overrides container width)
    // spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
    // concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre
    //     return node.degree();
    // },
    // levelWidth: function( nodes ){ // the letiation of concentric values in each level
    //     return nodes.maxDegree() / 4;
    // },
    // animate: true, // whether to transition the node positions
    // animationDuration: 500, // duration of animation in ms if enabled
    // animationEasing: undefined, // easing of animation if enabled
    // animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
    // ready: undefined, // callback on layoutready
    // stop: undefined, // callback on layoutstop
    // transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts
}
});

cy.on('tap', 'node', function(){
try { // your browser may block popups
    window.open( this.data('href') );
} catch(e){ // fall back on url change
    window.location.href = this.data('href');
}
});

</script>
</div>
</article>
</div>
</div>
</div>

</div> <!-- body -->


</div> <!-- whole_wrapper -->
</body>
</html>